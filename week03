import heapq

GOAL = ((1, 2, 3),
        (4, 5, 6),
        (7, 8, 0))


MOVES = [(-1, 0), (1, 0), (0, -1), (0, 1)]


class Puzzle:
    def __init__(self, state, parent=None, move=None, g=0):
        self.state = state
        self.parent = parent
        self.move = move
        self.g = g
        self.h = self.manhattan()
        self.f = self.g + self.h

    def manhattan(self):
        distance = 0
        for i in range(3):
            for j in range(3):
                value = self.state[i][j]
                if value != 0:
                    goal_x = (value - 1)
                    goal_y = (value - 1) % 3
                    distance += abs(goal_x - i) + abs(goal_y - j)
        return distance

    def __lt__(self, other):
        return self.f < other.f


def get_blank_position(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j


def generate_neighbors(node):
    neighbors = []
    x, y = get_blank_position(node.state)

    for dx, dy in MOVES:
        nx, ny = x + dx, y + dy

        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = [list(row) for row in node.state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            new_state = tuple(tuple(row) for row in new_state)

            neighbor = Puzzle(new_state, node, (nx, ny), node.g + 1)
            neighbors.append(neighbor)

    return neighbors


def a_star(start_state):
    open_list = []
    closed_set = set()

    start_node = Puzzle(start_state)
    heapq.heappush(open_list, start_node)

    while open_list:
        current = heapq.heappop(open_list)

        if current.state == GOAL:
            return current

        closed_set.add(current.state)

        for neighbor in generate_neighbors(current):
            if neighbor.state not in closed_set:
                heapq.heappush(open_list, neighbor)

    return None


def print_solution(node):
    path = []
    while node:
        path.append(node.state)
        node = node.parent

    path.reverse()
    for step in path:
        for row in step:
            print(row)
        print()



start = ((1, 2, 3),
         (4, 0, 6),
         (7, 5, 8))

solution = a_star(start)

if solution:
    print("Solution Found:\n")
    print_solution(solution)
else:
    print("No solution exists.")
